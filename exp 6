def mod_inverse(a, m):
    # Find modular inverse of a under modulo m
    for i in range(1, m):
        if (a * i) % m == 1:
            return i
    return None

def affine_decrypt(ciphertext, a, b):
    ciphertext = ciphertext.upper()
    plaintext = ""
    a_inv = mod_inverse(a, 26)
    if a_inv is None:
        raise ValueError("Invalid 'a' - no modular inverse exists.")
    for ch in ciphertext:
        if ch.isalpha():
            p = (a_inv * (ord(ch) - ord('A') - b)) % 26
            c = chr(p + ord('A'))
        else:
            c = ch
        plaintext += c
    return plaintext

# Example usage
ciphertext = input("Enter ciphertext: ").strip().upper()

# From frequency analysis, found a=3, b=15
a, b = 3, 15

print(f"Using keys: a = {a}, b = {b}")
decrypted = affine_decrypt(ciphertext, a, b)
print("Decrypted text:", decrypted)
